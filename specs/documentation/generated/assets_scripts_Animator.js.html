<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: assets/scripts/Animator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: assets/scripts/Animator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Animator class that handles animation objects and callbacks
 * @date 5/29/2023 - 6:26:28 PM
 *
 * @class Animator
 * @typedef {Animator}
 */
class Animator {
	static instance = null;

	/**
     * Contructor for the Animator class
     * @date 5/29/2023
     * @constructor
     */
	constructor() {
		if (Animator.instance === null) {
			Animator.instance = this;
		} else {
			console.error("[ERROR] Use Animator.instance.");
		}

		this.animationObjs = [];
		// Set up interval
		this.animationIntervalDelay = 10; // ms
		this.animationInterval = null;
		this.#startAnimationInterval();
	}

	/**
     * Create a new interval for Animation
     * @date 5/29/2023
     */
	#startAnimationInterval() {
		// Clear interval if there is already one
		if (this.animationInterval !== null) {
			clearInterval(this.animationInterval);
		}
		// Make new interval
		this.animationInterval = setInterval(()=>this.#whenAnimationInterval(),
			this.animationIntervalDelay);
	}

	/**
     * Process animation interval for new animation
     * @date 5/29/2023
     */
	#whenAnimationInterval() {
		// What happens every animation interval,
		// run backwards so we can splice items out of it
		for (let i = this.animationObjs.length - 1; i >= 0; i--) {
			const animationObj = this.animationObjs[i];
			// Increment the timer inside the animation
			animationObj.timeSinceStart += this.animationIntervalDelay;
			// Process the animation object
			let nextValue = animationObj.from +
			((animationObj.to - animationObj.from)/animationObj.time) *
			animationObj.timeSinceStart;

			// Make sure that the next value never overshoots the "to" value
			nextValue = (animationObj.from - animationObj.to &lt; 0) ?
				Math.min(nextValue, animationObj.to) :
				Math.max(nextValue, animationObj.to);

			animationObj.setter(nextValue);
			if (animationObj.timeSinceStart > animationObj.time) {
				// Remove this animation as it ran its full time,
				// if has callback, call it
				if (this.animationObjs[i].callback) {
					this.animationObjs[i].callback();
				}
				// Remove obj from list
				this.animationObjs.splice(i, 1);
			}
		}
	}

	/**
     * Add a new animation object that will take
	 * the animation from `from` value to the `to` value
     * @date 5/29/2023 - 6:24:34 PM
     *
     * @param {float} from starting value of the animation
     * @param {float} to ending value of animation
     * @param {Function} getter to get current value of animated prop
     * @param {Function} setter to set new current value of animated prop
     * @param {float} time time to complete the animation
     * @param {Function} callback callback after the animation is done
     * @return {animationObj} from: any; to: any; getter: any;
	 *                        setter: any; time: any;
     *                        callback: any; timeSinceStart: number;
     */
	addAnimation(from, to, getter, setter, time, callback) {
		const animationObj = {
			from: from,
			to: to,
			getter: getter,
			setter: setter,
			time: time,
			callback: callback,
			timeSinceStart: 0
		};
		this.animationObjs.push(animationObj);
		return animationObj;
	}

	/**
     * Delete the given animation object
     * @date 5/29/2023
     *
     * @param {Animator} animationObj - The Animation object to delete
     * @param {Function} runCallback callback
     */
	deteleAnimation(animationObj, runCallback) {
		// TODO this runs in O(n), restructure to a map probably to make this O(1)
		const animationIndex = this.animationObjs.findIndex(animationObj);

		// If asked to still run the callback
		if (runCallback &amp;&amp; this.animationObjs[animationIndex].callback) {
			this.animationObjs[animationIndex].callback();
		}

		// Remove this object from the animation list early
		this.animationObjs.splice(animationIndex, 1);
	}
}

// instantiate a singleton instance
new Animator();
export default Animator;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="global.html#Animator">Animator</a></li><li><a href="global.html#TarotCard">TarotCard</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addFogBackground">addFogBackground</a></li><li><a href="global.html#bindGeneralButtons">bindGeneralButtons</a></li><li><a href="global.html#bindHomePageBtns">bindHomePageBtns</a></li><li><a href="global.html#createShuffleBtn">createShuffleBtn</a></li><li><a href="global.html#createShuffleCards">createShuffleCards</a></li><li><a href="global.html#displayGeneralUIElements">displayGeneralUIElements</a></li><li><a href="global.html#displayThreeOptions">displayThreeOptions</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initializeServiceWorker">initializeServiceWorker</a></li><li><a href="global.html#playCardSpreadAnimation">playCardSpreadAnimation</a></li><li><a href="global.html#playShuffleAnimation">playShuffleAnimation</a></li><li><a href="global.html#removeFogBackground">removeFogBackground</a></li><li><a href="global.html#resetCards">resetCards</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Mon Jun 05 2023 23:18:10 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
